---
title: 'Deployment & integration'
description: 'Run EventDBX under Docker, wire up client libraries, and operate the daemon in production.'
---

This page collects the operational bits that typically live beside the CLI quickstart: containerised runtimes, language clients, security defaults, and observability hooks.

## Run with Docker

```bash
# Pull the latest published release
docker pull thachp/eventdbx:tagname

# Start the daemon with persistent storage and required ports
docker run \
  --name eventdbx \
  --detach \
  --publish 7070:7070 \
  --publish 6363:6363 \
  --volume "$PWD/data:/var/lib/eventdbx" \
  thachp/eventdbx:tagname
```

- Mount a persistent volume so Merkle trees, schemas, and queued jobs survive restarts.
- Port `7070` exposes the HTTP API; `6363` is the control socket the CLI and plugins hit.
- Pass `--env EVENTDBX_RESTRICT=strict` or update `config.toml` inside the volume to enforce schema validation globally.

<Tip>The Docker image bundles the same `dbx` binary as the CLI, so you can exec into the container and run administrative commands without installing extra tooling.</Tip>

## JavaScript/TypeScript client

Install the official library with `pnpm add eventdbxjs` (or your preferred package manager) and bootstrap the client as soon as you have host + token details:

```ts
import { createClient } from 'eventdbxjs';

const client = createClient({
  ip: process.env.EVENTDBX_HOST,
  port: Number(process.env.EVENTDBX_PORT) || 6363,
  token: process.env.EVENTDBX_TOKEN,
  verbose: true, // keep in sync with verbose_responses in config.toml
});

await client.connect();

const snapshot = await client.create('person', 'p-110', 'person_registered', {
  payload: { name: 'Jane Doe', status: 'active' },
  metadata: { '@source': 'seed-script' },
  note: 'seed aggregate',
});

await client.apply('person', 'p-110', 'person_contact_added', {
  payload: { name: 'Jane Doe', status: 'active' },
  metadata: { note: 'seed data' },
});

const history = await client.events('person', 'p-110');
console.log('event count:', history.length);
```

Tokens can be passed inline (`--token`), exported as `EVENTDBX_TOKEN`, or minted automatically when the CLI proxies through a running server.

## Security defaults

- Tokens use Ed25519 signatures configured under `[auth]` in `config.toml`. Store the private key on the server only; distribute the public key to services that validate tokens.
- Event payloads, aggregate snapshots, and `tokens.json` encrypt transparently when you provide a data-encryption key via `dbx config --dek <base64>`. Metadata (aggregate ids, Merkle roots) stays readable so plugins and integrity checks continue working.

## Observability

- Prometheus-compatible metrics live under `/metrics` on the HTTP port. They include request latency, plugin queue depth, and retry counters so you can wire dashboards in Grafana, Datadog, or any collector that speaks the Prometheus exposition format.
- Use `dbx queue`, `dbx queue retry`, and `dbx queue clear` to inspect or remediate jobs that failed fan-out. Retries use exponential backoff until the plugin succeeds or the aggregate disappears.

## Backups and restores

Stop the server before snapshotting the data directory to avoid partial Merkle trees.

```bash
dbx backup --output ~/backups/eventdbx.tar.gz
dbx restore --input ~/backups/eventdbx.tar.gz --data-dir /var/lib/eventdbx
```

Pass `--force` to overwrite non-empty destinations and `--data-dir` to restore into a custom path.
